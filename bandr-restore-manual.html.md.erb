---
title: Restoring <%= vars.app_runtime_full %>
owner: Tanzu Application Service Release Engineering
---
<% current_page.data.title = "Installing #{vars.app_runtime_full}" %>

This topic provides an overview of how to restore
<%= vars.app_runtime_full %> (<%= vars.app_runtime_short %>) from a backup.

<%= partial 'evaluation_only' %>

<%= partial 'limitation_notes' %>

## <a id='overview'></a> Overview

Velero supports a granular restore, which means you can tell velero to restore only specific resources from the backup. Unfortunately this is not the case for <%= vars.app_runtime_short %> database backup, it has no granularity and all the organizations, spaces & application will be restored as one.

You do have 2 options while restoring <%= vars.app_runtime_short %>:
Restore to a new platform with no state - this scenario is typical for a full disaster recovery
Restore in place while deleting all current state of the platform - this scenario maybe used when things went so bad that it is worth losing some recent changes in favor of restoring a healthy baseline

* [Restore <%= vars.app_runtime_short %>](#restore-tas)
* [Monitor Restore Progress](#restore-monitoring)
* [Review a Completed Restore](#restore-review)

## <a id='prerequisites'></a> Prerequisites

You must have access to the <%= vars.app_runtime_short %> Velero backup artifacts you plan to restore.


## <a id='restore-tas'></a> Restore <%= vars.app_runtime_short %>

To restore a <%= vars.app_runtime_short %> backup:

* [Prepare the Velero Backup Artifacts](#restore-prepare)
* [Start a <%= vars.app_runtime_short %> Restore](#restore-start)

### <a id='restore-prepare'></a> Prepare the Velero Backup Artifacts

To prepare your <%= vars.app_runtime_short %> Velero backup artifacts:

1. Determine the name of the backup to be restored:

    ```
    $ velero backup get
    ```

1. (Optional) To see backup metadata for any of the backups,
generate a JSON file containing a snapshot of Cloud Foundry at the time of the backup.

    ```
    ./bin/get-backup-metadata.sh BACKUP-NAME OUTPUT-FILENAME
    ```

    Where:
    * `BACKUP-NAME` is the name of the backup you want to validate against.
    * `OUTPUT-FILENAME` is the name of the backup state JSON file to create.

    For example:
    <pre class="terminal">
    $ ./bin/get-backup-metadata.sh backup_1 output-file.json
    </pre>

### <a id='restore-start'></a> Start a <%= vars.app_runtime_short %> Restore of Tanzu Postgres

To restore <%= vars.app_runtime_short %> Tanzu Postgres Instances: 

1. To fetch the name of the backup to restore:

    ```
    kubectl -n postgres-dbs exec -t pgbackrest info --stanza=ccdb  
    ```

1. [Restore the CCDB Tanzu Postgres Database](#restore-ccdb)
1. [Restore the UAADB Tanzu Postgres Database](#restore-uaadb)


#### <a id='restore-ccdb'></a> Restore the CCDB Tanzu Postgres Database 

To restore <%= vars.app_runtime_short %> CCDB Tanzu Postgres Instance:

1. To fetch the pid for the CCDB `pg_auto_failover` child process:  

    ```
    kubectl -n postgres-dbs exec -t ccdb-0 -- ps -ef | grep "pg_autoctl: start/stop postgres" | grep -v grep | awk '{print $2}'
    ```

1. To stop the the CCDB `pg_auto_failover` child process:  

    ```
    kubectl -n postgres-dbs exec -t ccdb-0 -- kill -STOP CCDB-PID
    ```

    Where `CCDB-PID` is the pid you collected in the last step.

1. To stop the Postgres instance:  

    ```
    kubectl -n postgres-dbs exec -t ccdb-0 -- pg_ctl stop
    ```

1. To restore the CCDB Postgres database:  

    ```
    kubectl -n postgres-dbs exec -t ccdb-0 -- pgbackrest restore --stanza=ccdb --delta --db-include=cloud_controller --type name --target BACKUP-NAME
    ```

     Where `BACKUP-NAME` is the name of the backup you want to restore from.  

1. To restart the CCDB `pg_auto_failover` child process and restart the Postgres process:  

    ```
    kubectl -n postgres-dbs exec -t ccdb-0 -- kill -CONT CCDB-PID
    ```

    Where `CCDB-PID` is the pid you collected in the step above.

#### <a id='restore-uaadb'></a> Restore the UAADB Tanzu Postgres Database 

To restore <%= vars.app_runtime_short %> UAADB Tanzu Postgres Instance:

1. To fetch the pid for the UAADB `pg_auto_failover` child process:  

    ```
    kubectl -n postgres-dbs exec -t uaadb-0 -- ps -ef | grep "pg_autoctl: start/stop postgres" | grep -v grep | awk '{print $2}'
    ```

1. To stop the the UAADB `pg_auto_failover` child process:      

    ```
    kubectl -n postgres-dbs exec -t uaadb-0 -- kill -STOP UAADB-PID
    ```

    Where `UAADB-PID` is the pid you collected in the last step.

1. To stop the Postgres instance:  

    ```
    kubectl -n postgres-dbs exec -t uaadb-0 -- pg_ctl stop
    ```

1. To restore the UAADB Postgres database:  

    ```
    kubectl -n postgres-dbs exec -t uaadb-0 -- pgbackrest restore --stanza=uaadb --delta --db-include=uaa --type name --target BACKUP-NAME
    ```

     Where `BACKUP-NAME` is the name of the backup you want to restore from.  

1. To restart the UAADB `pg_auto_failover` child process and restart the Postgres process:  

    ```
    kubectl -n postgres-dbs exec -t uaadb-0 -- kill -CONT UAADB-PID
    ```

    Where `UAADB-PID` is the pid you collected in the step above.
    ```
	
### <a id='restore-validate'></a> Validate the Restore

Given a restore has completed and there were no errors or warnings,
the backup-recovery solution provides a simple way to help validate the restored Cloud Foundry data.

The Cloud Foundry Metadata reporting tool provides a simple script to get the Cloud Foundry
state which was captured during a previous backup, and given this output can compare it to the live, running Cloud Foundry.

<p class="note"><strong>Note:</strong> This is not a perfect snapshot of the data in Cloud Foundry and should only be used as an aid to verifying the data.
The validation follows the Cloud Foundry constructs of “users, organizations, spaces and apps”
to measure what data was in Cloud Foundry during a backup.
</p>

To validate a completed restore:

1. If you do not have the <%= vars.app_runtime_short %> installation resources,
download the resources from [VMware Tanzu Network](https://network.pivotal.io/products/tas-for-kubernetes).
For more information, see [Preparing Installation Resources](preparing-to-install-tas-for-kubernetes.html#preparing-installation-resources).
1. Inspect the <%= vars.app_runtime_short %> artifact.
Confirm the following are present in the `tanzu-application-service/config/_ytt_lib/github.com/pivotal/cf-for-k8s-disaster-recovery/backup-metadata/bin` directory:
    * `get-backup-metadata.sh`
    * `compare-backup-metadata.sh`
1. To determine the name of the backup used to restore your system:

    ```
    velero get backups
    ```

    For example:

    <pre class="terminal">
    $ velero get backups

    NAME    STATUS                       CREATED EXPIRES STORAGE LOCATION  SELECTOR
    backup_1 Completed 2020-03-24 14:12:29 +0000 UTC     21d          default    &lt;none&gt;
    </pre>

1. To generate a snapshot of the Cloud Foundry state at the time of the backup:

    ```
    tanzu-application-service/config/_ytt_lib/github.com/pivotal/cf-for-k8s-disaster-recovery/backup-metadata/bin/get-backup-metadata.sh BACKUP-NAME OUTPUT-FILENAME
    ```

    Where:
    * `BACKUP-NAME` is the name of the backup you restored.
    * `OUTPUT-FILENAME` is the name of the Cloud Foundry state file to create for the backup.
    The created state file is a JSON formatted file.

    For example:
    <pre class="terminal">
    $ ./bin/get-backup-metadata.sh backup_1 output-file.json
    </pre>

1. To compare the backup state to the restored system state:

    ```
    tanzu-application-service/config/_ytt_lib/github.com/pivotal/cf-for-k8s-disaster-recovery/backup-metadata/bin/compare-backup-metadata.sh OUTPUT-FILENAME
    ```
    Where `OUTPUT-FILENAME` is the name of the backup state JSON file created in the previous step.
<br>
    The script displays the difference between the current restored Cloud Foundry state and
    the system's state at the time the backup was created.
